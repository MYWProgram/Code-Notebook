<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>浏览器滚动</title>
    <style>
      * {
        scroll-behavior: smooth;
      }
      input[type="radio"]:checked + div {
        display: block;
      }
      /* 案例一对应 CSS 代码。 */
      .example-back-to_top {
        width: 100%;
        height: 9999px;
        position: absolute;
        display: none;
      }
      .wrapper {
        height: 100px;
        width: 100px;
        margin: 0 auto;
        border: 1px solid #333333;
        background-color: red;
      }
      .back-to-top_link {
        position: fixed;
        top: 10%;
        right: 1%;
      }
      .scrollTo-button {
        position: fixed;
        top: 14%;
        right: 0;
      }
      .scrollBy-button {
        position: fixed;
        top: 18%;
        right: 0;
      }
      .scrollTop-button {
        position: fixed;
        top: 22%;
        right: 0;
      }
      /* 案例二对应 CSS 代码。 */
      .example-ele_show {
        width: 100%;
        height: 9999px;
        position: absolute;
        display: none;
      }
      .box {
        height: 100px;
        width: 100px;
        margin: 800px auto;
        background-color: green;
      }
      .scrollIntoView-button {
        position: fixed;
        top: 10%;
        right: 0;
      }
      /* 案例三对应 CSS 代码。 */
      .example-go-to_bottom {
        width: 100%;
        height: 9999px;
        position: absolute;
        display: none;
      }
      .scrollHeight-button {
        position: fixed;
        top: 10%;
        right: 0;
      }
      /* 案例四对应 CSS 代码。 */
      .example-mobile {
        width: 100%;
        height: 9999px;
        position: absolute;
        display: none;
      }
      .text-box {
        width: 100px;
        height: 150px;
        margin: 0px auto;
        overflow: auto;
        /* 注意这里的 -webkit- 前缀。 */
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
      }
      /* 案例五对应 CSS 代码。 */
      .example-mobile-scroll_y {
        width: 100%;
        height: 9999px;
        position: absolute;
        display: none;
      }
      .scroller {
        height: 300px;
        overflow-y: scroll;
        scroll-snap-type: y mandatory;
      }
      .scroller section {
        height: 100%;
        scroll-snap-align: start;
      }
      section:first-child {
        background-color: red;
      }
      section:nth-child(2) {
        background-color: lightblue;
      }
      section:last-child {
        background-color: yellow;
      }
    </style>
  </head>
  <!-- 
    * 1. 返回顶部：
    *    常用的浏览器滚动 API 包括 window.scrollTo、window.scrollBy 或者直接设置元素( HTML )的 scrollTop 值。
    *    前两个 API 用法相近；并且都可以设置 smooth 平滑滚动。只是后者是相对于滚动条的滚动，就是每次在滚动条当前基础上增加设置的偏移量。
    * 2. 指定元素出现在视窗中：
    *    可以使用上一个例子中提到的 window.scrollTo ，首先获取元素的 offsetTop 然后滚动到那个位置；
    *    也可以使用 a 标签锚点，href 设置为这个元素的 id；
    *    这里介绍一个新属性：scrollIntoView
    * 注意：想要让滚动条进行平滑过渡，不仅可以使用 behavior: smooth 还可以使用 CSS html {scroll-behavior: smooth;}
    * 3. 去底部：
    *    主要用到了一个新的兼容属性 scrollingElement，该对象可以优雅地获取到 scrollTop、scrollHeight
    *    还记得以前的兼容代码：let scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight; 吗？
    *    这个属性获取的：标准模式返回文档根元素或者 documentElement，怪异模式下返回 body。 
    *    我们还可以引申出判断是否已经到达底部这个判断：
    * 4. 移动端顺滑问题以及连滚
    *    iOS 设备在局部滚动中可能会出现不顺畅的现象，需要设置 CSS 属性：-webkit-overflow-scrolling: touch; 但是需要真机才可以看出效果，建议使用 liriliri/eruda 进行手机端查看。
    *    连滚也就是在局部滚动结束之后的全局滚动：通常懒加载的时候我们只需要局部下拉加载，但是这个局部的滚动也许会影响全局滚动，如果全局也有下拉加载就乱套了。
    *    处理的方式首先可以想到事件穿透，pointer-events；当局部滚动到底部的时候，给他添加 CSS 属性，但是还要写 JS ，不够简单。
    *    这时候可以使用 CSS 属性：overscroll-behavior: contain; 来阻止继续滚动。
    * 5. Y 轴全屏轮播（常用于移动端）
    *    这种全屏轮播的效果，之前都是使用 JS 来实现的，得益于 CSS 的新属性，现在不需要依赖 JS，并且效果也不错。
    *    这一些列属性作用就是：网页容器滚动停止的时候，自动平滑定位到指定元素的指定位置。
    *    scroll-snap-type: mandatory; 在外层容器设置这个属性值，当没有被滚动时，将静止在一个 snap 点，也就是说会自动选择一个完整的点进行停靠。
    *    scroll-snap-align: start; 对外层子项目设置这个属性，滚动结束会停靠于子项目起点。
    *    记得 iOS 移动端配合上：-webkit-overflow-scrolling: touch；
  -->
  <body>
    <!-- 案例一对应 HTML 代码。 -->
    <input type="radio" name="showExample" />返回顶部
    <div class="example-back-to_top">
      <a class="back-to-top_link" href="#">href</a>
      <button class="scrollTo-button">scrollTo</button>
      <button class="scrollBy-button">scrollBy</button>
      <button class="scrollTop-button">scrollTop</button>
    </div>

    <!-- 案例二对应 HTML 代码。 -->
    <input type="radio" name="showExample" />元素出现在视窗
    <div class="example-ele_show">
      <div class="box"></div>
      <button class="scrollIntoView-button">scrollIntoView</button>
    </div>

    <!-- 案例三对应 HTML 代码。 -->
    <input type="radio" name="showExample" />去底部
    <div class="example-go-to_bottom">
      <button class="scrollHeight-button">scrollHeight</button>
    </div>

    <!-- 案例四对应 HTML 代码。 -->
    <input type="radio" name="showExample" />移动端顺滑及连滚
    <div class="example-mobile">
      <div class="text-box">
        这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容这是内容
      </div>
    </div>

    <!-- 案例五对应 HTML 代码。 -->
    <input type="radio" name="showExample" />Y 轴全屏轮播
    <div class="example-mobile-scroll_y">
      <article class="scroller">
        <section>
          <h2>Section one</h2>
        </section>
        <section>
          <h2>Section two</h2>
        </section>
        <section>
          <h2>Section three</h2>
        </section>
      </article>
    </div>

    <script>
      // 针对案例三的简易节流。
      const throttle = function(fn, interval = 500) {
        let run = true;
        return function() {
          if (!run) return;
          run = false;
          setTimeout(() => {
            fn.apply(this, arguments);
            run = true;
          }, interval);
        };
      };
      // 针对案例三的简易防抖。
      const debounce = function(fn, interval = 500) {
        let timeout = null;
        return function() {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            fn.apply(this, arguments);
          }, interval);
        };
      };
      // 案例一对应 JS 代码。
      document
        .querySelector(".scrollTo-button")
        .addEventListener("click", function() {
          window.scrollTo({
            left: 0,
            top: 0,
            behavior: "smooth"
          });
        });
      document
        .querySelector(".scrollBy-button")
        .addEventListener("click", function() {
          window.scrollBy({
            left: 0,
            top: 1080,
            behavior: "smooth"
          });
        });
      document
        .querySelector(".scrollTop-button")
        .addEventListener("click", function() {
          document.scrollingElement.scrollTop = 0;
        });
      // 案例二对应 JS 代码。
      document
        .querySelector(".scrollIntoView-button")
        .addEventListener("click", function() {
          document.querySelector(".box").scrollIntoView({
            behavior: "smooth",
            // block 的取值还可以是 start、center ，对应视窗的顶部和中部。
            block: "end"
          });
        });
      // 案例三对应 JS 代码。
      document
        .querySelector(".scrollHeight-button")
        .addEventListener("click", function() {
          window.scrollTo({
            left: 0,
            // 获取当前外层可滚动元素的可滚动高度，也就是滚动条拉到最下面的高度。
            top: document.scrollingElement.scrollHeight,
            behavior: "smooth"
          });
        });
      window.addEventListener("scroll", () => {
        /**
         * 注意这个打印值，滚动的时候是不是一直在打印？
         * 一直触发肯定会影响网页的性能，虽然这里不会！但是还是需要加入简单的防抖节流处理一下。
         * 拓展：防抖是为了判断动作结束，优化性能；节流是为了减少代码频繁执行，应对压力测试。
         * 为了方便查看，单独在后面监听 scroll 。
         */
        // console.info("在滚在滚！");
        // 解构赋值，可以打印一下看看。
        let {
          scrollTop,
          scrollHeight,
          clientHeight
        } = document.scrollingElement;
        // 当前滚动高度 + 视口高度 >= 文档总高度。
        if (scrollTop + clientHeight >= scrollHeight) {
          confirm("已到达底部");
        }
      });
      // 加入防抖或者节流之后。
      window.addEventListener(
        "scroll",
        debounce(() => console.log("滚动结束！"))
      );
      window.addEventListener(
        "scroll",
        throttle(() => console.log("我在滚我在滚！"))
      );
    </script>
  </body>
</html>
